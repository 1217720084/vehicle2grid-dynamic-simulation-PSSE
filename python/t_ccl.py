import channel_utilsimport dynamic_simulationimport dyntoolsimport disturbancesimport channel_utilsimport osimport IOUtilsimport timeimport psspy_importimport controlimport utilsimport osimport power_systemimport dyntoolsimport IOUtilsfrom random import randrangecurrent_milli_time = lambda: int(round(time.time() * 1000))def determineT_ccl( dynamic_simulation,                    tolerance = .0001,                    res_file = "",                    pretty_print = True,                    progress = True                    ):    """Calculates the critical clearing time within the specified tolerance by doing a binary search. The results are writen to the res_file  specified as a parameter or to the default res_file given in IOUtils. If pretty print is on, then the result is formatted for human readability, otherwise its left as a space separated list of values, suitable for automatic processing. The dynamic simulation object might change.    """    min_t_ccl = 0.0    max_t_ccl = .4    channel_dir = "channels"    if not os.path.exists(channel_dir):        os.mkdir(channel_dir)     start = current_milli_time()    while max_t_ccl-min_t_ccl > tolerance:        mid = (min_t_ccl+max_t_ccl)/2        if progress:            IOUtils.log("Trying with "+str(mid)+"\n")        #channel_file = channel_dir+"\\gop_"+str(mid)+"_"+str(dynamic_simulation._disturbance)+"_"+str(dynamic_simulation._control)+".out"        channel_file = channel_dir+"\\"+str(hex(randrange(1000000000)))+".out"        dynamic_simulation._plot = False        dynamic_simulation._disturbance.setFaultDuration(mid)        dynamic_simulation._channels.setChannelFile(channel_file)        dynamic_simulation._control.setSimulation(dynamic_simulation)        dynamic_simulation.runSimulation()        start_channel,end_channel,channel_string_ids = dynamic_simulation._channels._channels[channel_utils.CHANNELS.SPEED]        converged = _isConverged(channel_file,range(start_channel,end_channel),dynamic_simulation._num_iterations/10)        if progress:            IOUtils.log("Finished with "+str(mid)+" res:"+str(converged)+"\n")        if converged:            min_t_ccl = mid        else:            max_t_ccl = mid        os.remove(channel_file)    end = current_milli_time()    if progress:        IOUtils.log("Time to compute t_ccl: "+str((end-start)/1000)+" s\n")    result = (min_t_ccl+max_t_ccl)/2    result_to_output = str(dynamic_simulation._disturbance._bus)+" "+str(dynamic_simulation._control._control_constant)+" "+str(result)+"\n"    if pretty_print:        result_to_output = str(dynamic_simulation._disturbance).ljust(40)+str(dynamic_simulation._control).ljust(35)+str(round(result,4)).ljust(10)+"\n"    if res_file == "":        IOUtils.res(result_to_output)    else:        IOUtils.logToFile(result_to_output,res_file)    return resultdef _isConverged(channel_file,speed_channels,indexes):    chan = dyntools.CHNF(channel_file)    short_title, chanid_dict, chandata_dict = chan.get_data()    average_frequency_deviation = 0    for speed_channel in speed_channels:        average_frequency_deviation += sum([i ** 2 for i in chandata_dict[speed_channel][-indexes:]])/indexes    average_frequency_deviation = average_frequency_deviation/len(speed_channels)    #IOUtils.log("average_frequency_deviation ="+str(average_frequency_deviation)+ "\n")    return average_frequency_deviation<.001    def main():    """Calculates the t_ccl for a bus fault at bus 18 in case 39"""    builder = dynamic_simulation.DynamicSimulationBuilder().withControl(control.NoControl()).\        withRawFile("normal_case39.raw").withDyrFile("normal_case39.dyr").\        withDisturbance(disturbances.BusFault(1,.5,18)).\        withEndTime(20).withNumIterations(2000)    determineT_ccl(builder.build())    if __name__ == "__main__":    main()