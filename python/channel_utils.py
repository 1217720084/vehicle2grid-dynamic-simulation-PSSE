import utilsimport psspyimport dyntoolsimport IOUtilsimport osdef enum(*sequential, **named):    enums = dict(zip(sequential, range(len(sequential))), **named)    reverse = dict((value, key) for key, value in enums.iteritems())    enums['reverse_mapping'] = reverse    return type('Enum', (), enums)	#Defines channels that can be added when the dynamic simualtion is definedCHANNELS = enum('SPEED','ANGLE','P_MECH','P_ELEC','P_LOAD','V','PEV_POWER','PEV_SPEED')#create the channels directory if it doesn't already existif not os.path.exists("channels"):    os.makedirs("channels")def _generateUniqueChannelName(machine_bus,quantity):    return str(quantity)+" AT "+str(machine_bus)    def _addLoadQuantityToChannel(channel_count,load_buses,quantity):	channels = []	for load_bus in load_buses:		channel_name = _generateUniqueChannelName(load_bus,quantity)		channels.append(str(channel_count)+" - "+channel_name)		psspy.load_array_channel([channel_count,quantity,load_bus],"1",channel_name)		channel_count += 1	return channel_count,channels    def _addSpeedQuantityToChannel(channel_count,buses):	channels = []	for bus in buses:		channel_name = _generateUniqueChannelName(bus,1)		channels.append(str(channel_count)+" - "+channel_name)		psspy.bus_frequency_channel([channel_count,bus],channel_name)		channel_count += 1	return channel_count,channelsdef _addMachineQuantityToChannel(channel_count,machine_buses,quantity):    channels = []    for machine_bus in machine_buses:        channel_name = _generateUniqueChannelName(machine_bus,quantity)        channels.append(str(channel_count)+" - "+channel_name)        psspy.machine_array_channel([channel_count,quantity,machine_bus],"1",channel_name)        channel_count += 1    return channel_count,channels	def _addVoltages(channel_count,buses):	channels = []	for bus in buses :		channel_name = "V AT "+str(bus)		channels.append(str(channel_count)+" - "+channel_name)		psspy.voltage_channel([channel_count,-1,-1,bus],channel_name)		channel_count += 1	return channel_count,channels        	class Channels(object):    """Holds channel info for a single PSS/E scenario run - which channel holds which information, channel file    _channels - a dictionary with keys CHANNELS (enum), values are tuples (start_channel,end_channel,channel_string_ids)    """        _channels = {}        def __init__(self,channel_file,channels_to_include,power_system):        self._channel_file = channel_file        self._channels_to_include = channels_to_include        self._power_system = power_system            def setChannelFile(self,channel_file):        self._channel_file = channel_file            def setUpChannels(self):        """Adds all the channels specified in _channels_to_include to the running dynamic simulation in PSS/E"""        generator_buses = self._power_system.getGeneratorBuses();        load_buses = self._power_system.getLoadBuses();                if CHANNELS.SPEED not in self._channels_to_include:            channels_to_include.append(CHANNELS.SPEED)        channel_count = 1        for each in self._channels_to_include:            channels = []            #please put this into functions for each enum, looks very ugly            if each is CHANNELS.SPEED:                channel_count,channels = _addMachineQuantityToChannel(channel_count,generator_buses,7)            if each is CHANNELS.ANGLE:                channel_count,channels = _addMachineQuantityToChannel(channel_count,generator_buses,1)            if each is CHANNELS.P_MECH:                channel_count,channels = _addMachineQuantityToChannel(channel_count,generator_buses,6)            if each is CHANNELS.P_ELEC:                channel_count,channels = _addMachineQuantityToChannel(channel_count,generator_buses,2)            if each is CHANNELS.P_LOAD:                channel_count,channels = _addLoadQuantityToChannel(channel_count,load_buses,1)            if each is CHANNELS.V:                channel_count,channels = _addVoltages(channel_count,range(1,self._power_system._nbus+1))            if each is CHANNELS.PEV_POWER:                for pev in self._power_system._pevs:                    channels.append(str(channel_count)+" - "+str(pev._bus)+" PEV")                    psspy.load_array_channel([channel_count,1,pev._bus],pev._id,str(pev._bus)+" PEV")                    channel_count += 1            if each is CHANNELS.PEV_SPEED:                channel_count,channels = _addSpeedQuantityToChannel(channel_count,[pev._bus for pev in self._power_system._pevs])            self._channels[each] = (channel_count-len(channels),channel_count,channels)        def plot(self,channels_to_plot):        """Plots all channels in PSS/E. You must run the dynamic simulation from within PSS/E in order to use their native ploting module."""        import pssplot        #read in channel data        pssplot.openchandatafile(self._channel_file)        #prepare environment for plotting        pssplot.newplotbook()        pssplot.insertpage()        for idx,each in enumerate(channels_to_plot):            start,end,channels = self._channels[each]            for channel_id in channels:                pssplot.dragdropplotdata(self._channel_file,channel_id)            if idx < len(channels_to_plot)-1:                pssplot.insertplot()                                        def exportToMatlab(self,matlab_file,description,plot=True,title=True,export=True):        """Exports all the channel data to a matlab file in a format suitable for running in matlab, mainly for plotting.        All channels are given as separate matrices, with a common time array specified first. Also automatically plots the channels in separate figures if plot is true. If export is true, it exports the figures to pdf files using export_fig.        """                #load the data from the channel file        chan = dyntools.CHNF(self._channel_file)        short_title, chanid_dict, chandata_dict = chan.get_data()                #open an m file for writing the results        with open(matlab_file,"w") as out:            out.write("set(0,'defaultlinelinewidth',.35);\n");                        #first output the time array            out.write("t = "+str(chandata_dict["time"])+";\n");            #then iterate over all CHANNELS and output them as matrices            for each in self._channels:                var_name = CHANNELS.reverse_mapping[each]                out.write(var_name+" = [")                start_channel,end_channel,channel_string_ids = self._channels[each]                for channel_id in range(start_channel,end_channel):                    out.write(str(chandata_dict[channel_id]))                    out.write(";")                out.write("];\n")                if plot:                    #and plot them in separate figures with                    out.write("figure;plot(t,"+var_name+");")                    if title:                        out.write("title('"+description.replace("_"," ")+"');")                    out.write("xlabel('Time [s]');ylabel('"+var_name.replace("_"," ")+"');\n")                    out.write("xlim([0,t(length(t))]);")                    #if specified add commands to export them to pdfs                    if export:                        out.write("export_fig -transparent "+var_name+"_"+description+".png\n")        def _floor_key(d, key):        if key in d:            return key        return max(k for k in d if k < key)    def _ceil_key(d, key):        if key in d:            return key        return min(k for k in d if k > key)            def getTimeOfStabilization(self,clearing_time,threshold=5e-08):        """returns the time when the average frequency deviation is smaller than a threshold, only meant to work for bus faults"""        chan = dyntools.CHNF(self._channel_file)        short_title, chanid_dict, chandata_dict = chan.get_data()        start_channel,end_channel,channel_string_ids = self._channels[CHANNELS.SPEED]        ind = 0        start_clearing = -1        for t in chandata_dict["time"]:            if t > clearing_time+0.3:                average_frequency_deviation = 0                for speed_channel in range(start_channel,end_channel):                    t_val = chandata_dict[speed_channel][ind]                    average_frequency_deviation += t_val*t_val                #IOUtils.log("current = {}\n".format(t_val))                average_frequency_deviation = average_frequency_deviation/(end_channel-start_channel)                if start_clearing > -1:                    if average_frequency_deviation < threshold:                        if t-start_clearing > 1:                            return start_clearing                    else:                        start_clearing = -1                else:                    if average_frequency_deviation < threshold:                        start_clearing = t            ind += 1        return -1                    def getAverageFrequencyDeviation(self,time):        """return the average generator frequency deviation at the specified time. Read from the channel file so this method is rather slow"""        chan = dyntools.CHNF(self._channel_file)        short_title, chanid_dict, chandata_dict = chan.get_data()        start_channel,end_channel,channel_string_ids = self._channels[CHANNELS.SPEED]        average_frequency_deviation = 0        t = chandata_dict["time"]        #IOUtils.log("current = {} time= {}\n".format(t[-1],time))        if t[0] > time:            return 0.0        if t[-1] <= time+0.001:            for speed_channel in range(start_channel,end_channel):                t_val = chandata_dict[speed_channel][-1]                average_frequency_deviation += t_val            #IOUtils.log("current = {}\n".format(t_val))            average_frequency_deviation = average_frequency_deviation/(end_channel-start_channel)        else:            min_t = max(k for k in t if k < time)            max_t = min(k for k in t if k > time)            idx_min_t = t.index(min_t)            idx_max_t = t.index(max_t)            for speed_channel in range(start_channel,end_channel):                min_val = chandata_dict[speed_channel][idx_min_t]                max_val = chandata_dict[speed_channel][idx_max_t]                t_val = min_val+(max_val-min_val)/(max_t-min_t)*(time-min_t)                #IOUtils.log("("+str(min_t)+","+str(min_val)+") ("+str(max_t)+","+str(max_val)+") ("+str(time)+","+str(t_val)+")\n")                #IOUtils.log("current = {} at t = {}\n".format(t_val,chandata_dict[speed_channel][-1]))                average_frequency_deviation += t_val            average_frequency_deviation = average_frequency_deviation/(end_channel-start_channel);        #IOUtils.log("{},".format(60*average_frequency_deviation))        return 60*average_frequency_deviation            def getFrequencyDeviationsForPEVS(self):            """Returns an array of frequency deviations at each PEV bus        """        chan = dyntools.CHNF(self._channel_file)        short_title, chanid_dict, chandata_dict = chan.get_data()        start_channel,end_channel,channel_string_ids = self._channels[CHANNELS.PEV_SPEED]        i = 0        res = []        for speed_channel in range(start_channel,end_channel):            res.append(60*chandata_dict[speed_channel][-1])        return res            def getFrequencysForPEVS(self):            """Returns an array of frequency deviations at each PEV bus        """        chan = dyntools.CHNF(self._channel_file)        short_title, chanid_dict, chandata_dict = chan.get_data()        start_channel, end_channel, channel_string_ids = self._channels[CHANNELS.PEV_SPEED]        i = 0        res = []        for speed_channel in range(start_channel,end_channel):            res.append(chandata_dict[speed_channel])        return res,chandata_dict["time"]